<#

### This Cmdlet Should:
- Import CSV list of Computer names and rename by referencing SN
    - Confirm correct format of CSV file (Column name matches criteria for correct referencing)
    - CSV file must contain at least Name and Serial Number
- Ask for confirmation before renaming

#>
function Rename-JamfComputerFromCsv {
    [CmdletBinding(ConfirmImpact='High',DefaultParameterSetName='Direct Rename')]
    <#
    .Synopsis
    Short description
    .DESCRIPTION
    Long description
    .EXAMPLE
    Example of how to use this cmdlet
    .EXAMPLE
    Another example of how to use this cmdlet
    .INPUTS
    Inputs to this cmdlet (if any)
    .OUTPUTS
    Output from this cmdlet (if any)
    .NOTES
    General notes
    .COMPONENT
    The component this cmdlet belongs to
    .ROLE
    The role this cmdlet belongs to
    .FUNCTIONALITY
    The functionality that best describes this cmdlet
    #>
    param (
        [Parameter(Mandatory=$true)]$JssAPIurl,

        [Parameter(Mandatory=$true)]
        [System.Management.Automation.CredentialAttribute()]
        [pscredential]
        $Credential,

        # Path to Xml report location generated by Jamf cmdlets.
        [Parameter(Mandatory=$true,
                   ParameterSetName='CSV Rename',
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   HelpMessage="Path to Xml report location generated by Jamf cmdlets.")]
        [Alias("Path")]
        [ValidateNotNullOrEmpty()]
        [ValidateScript({test-path $_})]
        [Alias('csv')]
        [string]
        $CSVReport
    )
    
    begin {
       
        # Validate CSV report:

        $csv = Get-Content -Path $CSVReport
        $csvarray = $csv.Split(',')
        $Validate = [bool](($csvarray -contains "Serial Number") -and ($csvarray -contains "Computer Name"))
        if ($Validate -eq $false) {
            Write-Error "Unable to validate CSV report. Please ensure report contains columns named 'Computer Name' and 'Serial Number'."
        }

        $csvobj = Import-Csv $CSVReport | select -Property "Computer Name","Serial Number"
        $csvsn = $csvobj | select -ExpandProperty "Serial Number"
        $csvnames = $csvobj | select -ExpandProperty "Computer Name"

        # Get computer info based on provided SN:
        
        $Computers += foreach ($sn in $csvsn) {
            try {

                $query = "computers/serialnumber/$SN"
                $Uri = "$JssAPIurl/JSSResource/$query"
                $r = Invoke-RestMethod -Uri $Uri -Credential $Credential -Method Get -ErrorAction SilentlyContinue -ErrorVariable ER
                $CompGen = $r.computer.general | select -Property "name","serial_number"
                $CompGen
                
            }
            catch {
                Write-Warning "A computer that matches $sn was not found, skipping renaming $($CompGen.name)"
            }
            

        }
        
        # ForEach computer object name that is not equal to other computer object name create variable that contains resultant computer objects that are different.
       
        $ToRenameComps += foreach ($comp in $csvobj) {
            if ($Computers.name -contains $comp.'Computer Name') {
                continue
            }
            else {
                $rename = $Computers | where {$_.serial_number -eq $comp.'Serial Number'}
                $rename
            }
            
        } 
        $RenamedComps += foreach ($comp in $Computers) {
            if ($csvobj.'Computer Name' -contains $comp.name) {
                continue
            }
            else {
                $renamed = $csvobj | where {$_.'Serial Number' -eq $comp.serial_number}
                $renamed
            }
            
        }
        $toRenamest = $ToRenameComps | select -ExpandProperty name
        $Renamedst= $RenamedComps | select -ExpandProperty 'Computer Name'

        if ($ToRenameComps -eq $null) {
            write-host "There are no devices to rename." -ForegroundColor Green
            exit
        }

        for ($i = 0; $i -lt $ToRenameComps.Length; $i++) {

            $Message = "Rename '$($toRenamest[$i])' to '$($Renamedst[$i])'"
            Write-Host $Message -ForegroundColor blue

        }
        
        # Ask for confirmation:

        $caption = "Choose Action";
        $message = "Rename the above computers?"
        $continue = new-Object System.Management.Automation.Host.ChoiceDescription "&Continue","Continue renaming computers";
        $stop = new-Object System.Management.Automation.Host.ChoiceDescription "&Stop","No computers will be renamed";
        $choices = [System.Management.Automation.Host.ChoiceDescription[]]($continue,$stop);
        $answer = $host.ui.PromptForChoice($caption,$message,$choices,0)

        switch ($answer){
            0 {"Renaming Computers..."}
            1 {"No changes made"; exit}
        }

        # Renaming:
        foreach ($rcmps in $RenamedComps) {
            
            try {
                Write-host "Renaming to $($rcmps.'Computer Name')" -ForegroundColor Magenta
                $query = "computers/serialnumber/$($rcmps.'Serial Number')"
                $Uri = "$JssAPIurl/JSSResource/$query"
                $body = "<computer><general><name>" + $($rcmps.'Computer Name') + "</name></general></computer>"
                $Putr = Invoke-RestMethod -Uri $Uri -Credential $Credential -Method Put -Body $body -ErrorAction SilentlyContinue -ErrorVariable RE
            }
            catch {
                Write-Warning "An error has occured while trying to rename $($rcmps.'Computer Name') read following error message:"
                Write-Output -InputObject $RE
            }
            
        }

    }
    
    process {
        
        
    }
    
    end {


    }
}